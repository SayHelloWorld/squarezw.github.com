<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: CocoaFramework | square's blog]]></title>
  <link href="http://doruby.com/blog/categories/cocoaframework/atom.xml" rel="self"/>
  <link href="http://doruby.com/"/>
  <updated>2014-03-31T16:31:33+08:00</updated>
  <id>http://doruby.com/</id>
  <author>
    <name><![CDATA[square]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 上的蓝牙框架 - Core Bluetooth for iOS [译]]]></title>
    <link href="http://doruby.com/blog/2013/08/15/core-bluetooth-for-ios/"/>
    <updated>2013-08-15T09:52:00+08:00</updated>
    <id>http://doruby.com/blog/2013/08/15/core-bluetooth-for-ios</id>
    <content type="html"><![CDATA[<p>所须环境: iOS 6 以上</p>

<p>原文: <a href="http://weblog.invasivecode.com/post/39707371281/core-bluetooth-for-ios-6-core-bluetooth-was">Core Bluetooth for iOS 6</a></p>

<p>Core Bluetooth 是在iOS5首次引入的，它允许iOS设备可以使用健康，运动，安全，自动化，娱乐，附近等外设数据。在iOS 6 中，这个API被扩展了，让iOS也能成为数据提供方，也就是<code>Server(Peripheral)</code>端，可能使它与其它 iOS 设备交互数据。</p>

<p>Core Bluetooth API 基于BLE4.0规范。这个框架涵盖了BLE标准的所有细节. 不过，仅仅只有新的iOS设备和MAC是兼容BLE标准的: iPhone 4S, iPhone5, Mac Mini, New iPad, MacBook Air, MacBook Pro. 并且 iOS 6 iPhone 模拟器也支持一样的标准.这对你在没有真机时，开发APP时是非常实用的。</p>

<h2>相关的类</h2>

<p>在CoreBluetooth框架中，有两个主要的角色：外设和中心（Peripheral and Central） ，整个框架都是围绕这两个主要角色设计的，它们之间有一系列的回调交换数据。
下图1展示了外设和中心（<code>Peripheral and Central</code>）的关系。</p>

<p><img src="/assets/core_bluetooth_client_server_naming.png" alt="Fig1" /></p>

<p>外设创建或提供一些数据，中心使用这些设备提供的数据。在iOS6之后，iOS 设备也可以即是外设，也可以是中心，但不能在同时间扮演两个角色。</p>

<p>这两个组件在CoreBluetooth框架中是分别用两个类来表示的，中央是<code>CBCentralManager</code>类，外设是<code>CBPeripheralManager</code>类。</p>

<p>在中心，一个 <code>CBPeripheral</code> 对象表示正在连接中的外设,同样在外设里，一个 <code>CBCentral</code> 表示正在连接中的中心.</p>

<p>你可以理解外设是一个广播数据的设备，它开始告诉外面的世界说它这儿有一些数据，并且能提供一些服务。另一边中心开始扫描外面有没有
自己所需要的服务，如果发现后，会和外设做连接请求，一旦连接确定后，两个设备就可以传输数据了。</p>

<p>除了中心与外设，我们还得考虑他们用于交互的数据结构，这些数据在Services(服务)中被结构化,每个服务由不同的Characteristics(特性)所组成。特性定义为一种属性类型，并且对应一个逻辑值(比如0x2A49)。</p>

<p>你可以在<a href="http://developer.bluetooth.org">developer bluetooth</a>这里找到标准服务与特性的列表。</p>

<p>比如：</p>

<!-- more -->


<p>```objc</p>

<h1>Services:</h1>

<p>SpecificationName: Blood Pressure
SpecificationType: org.bluetooth.service.blood_pressure
AssignedNumber: 0x1810
SpecificationLevel: Adopted</p>

<h1>Characteristics:</h1>

<p>SpecificationName: Blood Pressure Feature
SpecificationType: org.bluetooth.characteristic.blood_pressure_feature
AssignedNumber: 0x2A49
SpecificationLevel: Adopted
```</p>

<p>在中心里，服务由 <code>CBService</code> 类表示，每个服务由代表特性的 <code>CBCharacteristic</code>类所构成。</p>

<p>同样，在外设中服务与特性由 <code>CBMutableService</code> 与 <code>CBMutableCharacteristicclass</code> 类表示。</p>

<p>下图解释了他们之间的关系:</p>

<p><img src="/assets/objects_involved_in_core_bluetooth.png" alt="Fig2" /></p>

<p><code>CBUUID</code> 和 <code>CBATTRequest</code> 是两个苹果提供给我们的帮助类，以便于开发者更简单地操作数据，稍后你将看到如何使用它们。</p>

<h2>使用</h2>

<p>不幸的是，Apple提供的文档目前还不完整，你只有通过WWDC上两个关于 Core Bluetooth的视频和头文件，去理解这个框架是如何工作的。不过，因为我之前已经做过相关方面的事情，我决定和你分享这些内容，我希望下面的教程可以帮助到你。你也可以通过 http://training.invasivecode.com 查看我们的培训课程.</p>

<h4>创建外设 (Peripheral)</h4>

<p>为了可以创建一个完整的例子，你需要两台iOS设备，我将向你展示如何通过蓝牙连接这两个设备，并交换数据。记住先检查一下你的设备是不是被BLE所支持的。</p>

<p>开始创建一个外设需要下面几步：</p>

<p>1.创建并且开始Peripheral Manager</p>

<p>2.设置并且发布它的服务。</p>

<p>3.广播这个服务。</p>

<p>4.和中心连接。</p>

<p>用Single-View Application模板创建一个新的Xcode工程。命名为BlueServer （使用ARC）。工程创建完成后，添加CoreBluetooth.framework 框架。然后打开ViewController.h文件，并且添加以下代码：</p>

<p>```objc</p>

<h1>import &lt;CoreBluetooth/CoreBluetooth.h></h1>

<p>```</p>

<p>使view controller 遵循 <code>CBPeripheralManagerDelegate</code> 协议，然后添加这个属性：</p>

<p><code>objc
@property (nonatomic, strong) CBPeripheralManager *manager;
</code></p>

<p>在ViewController.m中，添加以下代码到viewDidLoad方法中：</p>

<p><code>objc
self.manager = [[CBPeripheralManager alloc] initWithDelegate:self queue:nil];
</code></p>

<p>这行代码初始化了一个 Peripheral Manager (计划中的第一项). 第一个参数是设置delegate(这里的例子就是view controller)。第二参数(队列)设置为了nil,因为Peripheral Manager 将运行在主线程中。如果你想用同步的线程做更复杂的事情，你需要单独创建一个队列并把它放在这个参数中。</p>

<p>一旦Peripheral Manager被初始化后，我们需要及时检查正在运行的App设备状态，是不是符合BLE标准的。所以你要实现下面的这个代理方法（如果设备不支持BLE,你可以友好地提醒用户。你还可以通过拿到的状态值做更多事情）。</p>

<p>```objc
- (void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral {</p>

<pre><code>switch (peripheral.state) {
    case CBPeripheralManagerStatePoweredOn:
        [self setupService];
        break;
    default:
        NSLog(@"Peripheral Manager did change state");
        break;
}
</code></pre>

<p>}
```</p>

<p>在这里，我检查了外设的状态，如果它的状态是<code>CBPeripheralManagerStatePoweredOn</code>，那这个设备是支持BLE并可以继续执行。</p>

<p>外设的状态包括有下面这些</p>

<p><code>objc
typedef enum {
   CBPeripheralManagerStateUnknown = 0,
   CBPeripheralManagerStateResetting,
   CBPeripheralManagerStateUnsupported,
   CBPeripheralManagerStateUnauthorized,
   CBPeripheralManagerStatePoweredOff,
   CBPeripheralManagerStatePoweredOn,
} CBPeripheralManagerState;
</code></p>

<h2>服务与特性 (Service &amp; Characteristic)</h2>

<p>setupService 是一个辅助方法，我们让它去准备服务和特性，对于这个例子，我们仅仅需要一个服务和一个特性。</p>

<p>每一个服务和特性必要有一个UUID来标识，UUID是一个16位或128位的值。如果你创建的是一个 client-server(中央-外设)应用，那么你需要创建属于你自己的128位UUID，你必须确保它不能和其他已经存在的服务冲突，如果你要创建一个新的设备，你需要去符合标准委员会的UUID。</p>

<p>如果你创建的是你自己的client-server(正如我们现在做的)，我建议你在Terminal下用 uuidgen 命令创建128位的UUID. 所以打开 Terminal并创建两个（一个为服务，一个为特性）.之后，你需要将他们添加到中心和外设应用。这里我们先添加下面几行在 view controller中。</p>

<p><code>objc
static NSString * const kServiceUUID = @"6BC6543C-2398-4E4A-AF28-E4E0BF58D6BC";
static NSString * const kCharacteristicUUID = @"9D69C18C-186C-45EA-A7DA-6ED7500E9C97";
</code>
注意：这里的UUID每个人生成的都不一样，最好是你自己生成</p>

<p>这里是 setupService 的实现方法:</p>

<p>```objc
- (void)setupService {</p>

<pre><code>// Creates the characteristic UUID
CBUUID *characteristicUUID = [CBUUID UUIDWithString:kCharacteristicUUID];

// Creates the characteristic
self.customCharacteristic = [[CBMutableCharacteristic alloc] initWithType:characteristicUUID properties:CBCharacteristicPropertyNotify value:nil permissions:CBAttributePermissionsReadable];

// Creates the service UUID
CBUUID *serviceUUID = [CBUUID UUIDWithString:kServiceUUID];

// Creates the service and adds the characteristic to it
self.customService = [[CBMutableService alloc] initWithType:serviceUUID primary:YES];

// Sets the characteristics for this service
[self.customService setCharacteristics:@[self.customCharacteristic]];

// Publishes the service
[self.peripheralManager addService:self.customService];
</code></pre>

<p>}
```</p>

<p>首先，我使用<code>+UUIDWithString:</code>方法创建了一个 UUID 对象，之后我用这个 UUID对象创建了特性。注意，我在初始化时，第三个参数传的是nil (那个value)，之所以这样做，是因为我告诉 Core Bluetooth我将稍候添加这个特性值，当你需要动态创建数据时，经常这么做。如果你已经有一个静态的值，你可以直接传它。</p>

<p>在这个方法中，第一个参数是先创建好的UUID,第二个参数(那个 properties)确定你将如何使用这个特性值，下面是这些可能的值：</p>

<p><code>objc
CBCharacteristicPropertyBroadcast: 允许一个广播特性值,用于描述特性配置，不允许本地特性
CBCharacteristicPropertyRead: 允许读一个特性值
CBCharacteristicPropertyWriteWithoutResponse: 允许写一个特性值，没有反馈
CBCharacteristicPropertyWrite: 允许写一个特性值
CBCharacteristicPropertyNotify: 允许通知一个特性值，没有反馈
CBCharacteristicPropertyIndicate: 允许标识一个特性值
CBCharacteristicPropertyAuthenticatedSignedWrites: 允许签名一个可写的特性值
CBCharacteristicPropertyExtendedProperties: 如果设置后，附加特性属性为一个扩展的属性说明，不允许本地特性
CBCharacteristicPropertyNotifyEncryptionRequired: 如果设置后，仅允许信任的设备可以打开通知特性值
CBCharacteristicPropertyIndicateEncryptionRequired: 如果设置后，仅允许信任的设备可以打开标识特性值
</code></p>

<p>最后一个参数是属性的读、写、加密权限，有以下几种：</p>

<p><code>objc
CBAttributePermissionsReadable
CBAttributePermissionsWriteable
CBAttributePermissionsReadEncryptionRequired
CBAttributePermissionsWriteEncryptionRequired
</code></p>

<p>创建特性后，我同样通过<code>+UUIDWithString:</code>方法创建 UUID，然后通过它创建了服务。 最后我为服务设置对应的这个特性。记住，每个服务可以包括多个特性，正如下面的图3</p>

<p><img src="/assets/services_and_characteristics.png" alt="Fig3" /></p>

<p>所以我们需要通过一个特性数组来添加到服务中，在这个例子里，这个数组对象只有一个特性。</p>

<p>最后一行的代码是将服务添加到 Peripheral Manager中，用于发布这个服务。一旦这样做之后，Peripheral Manager 将会通知它的 delegate调用<code>peripheralManager:didAddService:error:</code>方法。这里如果没有错误，你可以开始广播这个服务。</p>

<p>```objc
- (void)peripheralManager:(CBPeripheralManager <em>)peripheral didAddService:(CBService </em>)service error:(NSError *)error {</p>

<pre><code>if (error == nil) {
    // Starts advertising the service
    [self.peripheralManager startAdvertising:@{ CBAdvertisementDataLocalNameKey : @"ICServer", CBAdvertisementDataServiceUUIDsKey : @[[CBUUID UUIDWithString:kServiceUUID]] }];
}
</code></pre>

<p>}
```</p>

<p>当Peripheral Manager开始广播这个服务时，delegate 会接收到 <code>peripheralManagerDidStartAdvertising:error:</code> 消息。当中心订阅
了这个服务时，它的delegate会收到 <code>peripheralManager:central:didSubscribeToCharacteristic:</code>消息，这儿你可以生成动态数据给中心。</p>

<p>现在，发送数据给中心你需要预先写一些数据的代码，然后发送<code>updateValue:forCharacteristic:onSubscribedCentrals:</code>到外设。</p>

<h2>创建一个中心 (Central)</h2>

<p>现在，我们已经有了一个外设，让我们创建中心(client)。记住，中心是用来处理外设提供的数据的。如上面的图2所示，这里的中心被 <code>CBCentralManager</code> 对象表示。</p>

<p>让我们创建一个名字为 BlueClient 的 Xcode 项目，使用ARC,并添加 CoreBluetooth.framework ，在 view controller 头添加</p>

<p>```objc</p>

<h1>import &lt;CoreBluetooth/CoreBluetooth.h></h1>

<p>```</p>

<p>在中心，你必须遵循两个协议: CBCentralManagerDelegate 和 CBPeripheralDelegate</p>

<p><code>objc
@interface ViewController : UIViewController &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;
</code></p>

<p>并添加两个属性:</p>

<p><code>objc
@property (nonatomic, strong) CBCentralManager *manager;
@property (nonatomic, strong) NSMutableData *data;
</code></p>

<p>现在正如我们之前为外设创建的做法一样，我们创建中心对象:
<code>objc
self.manager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
</code></p>

<p>同样，这里的第一个参数表示 CBCentralManager delegate (这里是 view controller). 第二个参数和之前一样也表示调度队列，如果设置为空，他会使用主队列。</p>

<p>一旦 Central Manager 初始化后，我们同样也要检查它的状态，是不是被 BLE 所支持的APP，实现下面的delegate 方法:</p>

<p>```objc
- (void)centralManagerDidUpdateState:(CBCentralManager *)central {</p>

<pre><code>switch (central.state) {
    case CBCentralManagerStatePoweredOn:
        // Scans for any peripheral
        [self.manager scanForPeripheralsWithServices:@[ [CBUUID UUIDWithString:kServiceUUID] ] options:@{CBCentralManagerScanOptionAllowDuplicatesKey : @YES }];
        break;
    default:
        NSLog(@"Central Manager did change state");
        break;
}
</code></pre>

<p>}
```</p>

<p>这个<code>scanForPeripheralsWithServices:options:</code> 方法用于告诉 Central Manager 开始查看特别的服务，如果你第一个参数用的是nil，这个Central Manager 开始查看所有服务。</p>

<p>这个 kServiceUUID 和创建外设中的 ServiceUUID 一样。所以我们再次添加下面2行代码在你的实现类中。</p>

<p><code>objc
static NSString * const kServiceUUID = @"6BC6543C-2398-4E4A-AF28-E4E0BF58D6BC";
static NSString * const kCharacteristicUUID = @"9D69C18C-186C-45EA-A7DA-6ED7500E9C97";
</code></p>

<p>一旦一个外设在扫描时被发现后，中心 delegate 会收到下面的回调：</p>

<p><code>objc
- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI
</code></p>

<p>这个调用通知Central Manager delegate（在这个例子中就是view controller），一个附带着广播数据和信号质量(RSSI-Received Signal Strength Indicator)的周边被发现。这是一个很酷的参数，知道了信号质量，你可以用它去估计中心与外设的距离。</p>

<p>任何广播或扫描的响应数据保存在advertisementData 中，可以通过CBAdvertisementData key来访问它。现在，你可以停止扫描，去连接外设了：</p>

<p>```objc
- (void)centralManager:(CBCentralManager <em>)central didDiscoverPeripheral:(CBPeripheral </em>)peripheral advertisementData:(NSDictionary <em>)advertisementData RSSI:(NSNumber </em>)RSSI {</p>

<pre><code>// Stops scanning for peripheral
[self.manager stopScan];

if (self.peripheral != peripheral) {
    self.peripheral = peripheral;
    NSLog(@"Connecting to peripheral %@", peripheral);
    // Connects to the discovered peripheral
    [self.manager connectPeripheral:peripheral options:nil];
}
</code></pre>

<p>}
```</p>

<p>options 参数是一个可选的字典(NSDictionary)，如果需要，可以用以下的键(keys), 它们的值始终是一个boolean。</p>

<p><code>objc
CBConnectPeripheralOptionNotifyOnConnectionKey: 这是一个NSNumber(Boolean)，表示系统会为获得的外设显示一个提示，当成功连接后这个应用被挂起，这对于没有运行在中心后台模式并不显示他们自己的提示时是有用的。如果有更多的外设连接后都会发送通知，如果附近的外设运行在前台则会收到这个提示。
CBConnectPeripheralOptionNotifyOnDisconnectionKey:  这是一个NSNumber(Boolean), 表示系统会为获得的外设显示一个关闭提示，如果这个时候关闭了连接，这个应用会挂起。
CBConnectPeripheralOptionNotifyOnNotificationKey: 这是一个NSNumber(Boolean)，表示系统会为获得的外设收到通知后显示一个提示，这个时候应用是被挂起的。
</code></p>

<p>基于连接的结果，delegate会接收
<code>objc
- centralManager:didFailToConnectPeripheral:error:
</code>
或者
<code>objc
- centralManager:didConnectPeripheral:
</code>中的一个。如果成功了，你可以询问正在广播服务的那个外设。因此，在didConnectPeripheral 回调中，你可以写以下代码：</p>

<p>```objc
- (void)centralManager:(CBCentralManager <em>)central didConnectPeripheral:(CBPeripheral </em>)peripheral {</p>

<pre><code>// Clears the data that we may already have
[self.data setLength:0];
// Sets the peripheral delegate
[self.peripheral setDelegate:self];
// Asks the peripheral to discover the service
[self.peripheral discoverServices:@[ [CBUUID UUIDWithString:kServiceUUID] ]];
</code></pre>

<p>}
```</p>

<p>现在，外设开始用一串回调通知它的delegate。在上面一个方法中，我请求外设去寻找服务，外设代理收到 -peripheral:didDiscoverServices:
如果没有错误，外设可以去查找服务所提供特性，你可以这样做。</p>

<p>```objc
- (void)peripheral:(CBPeripheral <em>)aPeripheral didDiscoverServices:(NSError </em>)error {</p>

<pre><code>if (error) {
    NSLog(@"Error discovering service: %@", [error localizedDescription]);
    [self cleanup];
    return;
}

for (CBService *service in aPeripheral.services) {
    NSLog(@"Service found with UUID: %@", service.UUID);

    // Discovers the characteristics for a given service
    if ([service.UUID isEqual:[CBUUID UUIDWithString:kServiceUUID]]) {
        [self.peripheral discoverCharacteristics:@[[CBUUID UUIDWithString:kCharacteristicUUID]] forService:service];
    }
}
</code></pre>

<p>}
```</p>

<p>现在，如果一个特性被发现，外设delegate 又会接收
<code>objc
peripheral:didDiscoverCharacteristicsForService:error:
</code></p>

<p>```objc
- (void)peripheral:(CBPeripheral <em>)peripheral didDiscoverCharacteristicsForService:(CBService </em>)service error:(NSError *)error {</p>

<pre><code>if (error) {
    NSLog(@"Error discovering characteristic: %@", [error localizedDescription]);
    [self cleanup];
    return;
}
if ([service.UUID isEqual:[CBUUID UUIDWithString:kServiceUUID]]) {
    for (CBCharacteristic *characteristic in service.characteristics) {
        if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:kCharacteristicUUID]]) {
            [peripheral setNotifyValue:YES forCharacteristic:characteristic];
        }
    }
}
</code></pre>

<p>}
<code>``
一旦特征的值用</code>setNotifyValue:forCharacteristic:` 更新后，外设就会通知它的delegate。</p>

<p>外设的 delegate 就会接收到
<code>objc
peripheral:didUpdateNotificationStateForCharacteristic:error:
</code>
这里，你可以用 <code>readValueForCharacteristic:</code> 读到新的值</p>

<p>```objc
- (void)peripheral:(CBPeripheral <em>)peripheral didUpdateNotificationStateForCharacteristic:(CBCharacteristic </em>)characteristic error:(NSError *)error {</p>

<pre><code>if (error) {
    NSLog(@"Error changing notification state: %@", error.localizedDescription);
}

// Exits if it's not the transfer characteristic
if (![characteristic.UUID isEqual:[CBUUID UUIDWithString:kCharacteristicUUID]]) {
    return;
}

// Notification has started
if (characteristic.isNotifying) {
    NSLog(@"Notification began on %@", characteristic);
    [peripheral readValueForCharacteristic:characteristic];
} else { // Notification has stopped
    // so disconnect from the peripheral
    NSLog(@"Notification stopped on %@.  Disconnecting", characteristic);
    [self.manager cancelPeripheralConnection:self.peripheral];
}
</code></pre>

<p>}
<code>``
当外设发送新的值时，外设的 delegate 会收到</code>peripheral:didUpdateValueForCharacteristic:error:<code>，这个方法的第二个参数包含特性，你可以用</code>-value` 属性来读它，这是一个包含了特性值的NSData。</p>

<p>这个时候，你可以为其它数据断开或等待。</p>

<h2>总结</h2>

<p>我为你展示了如何使用 Core Bluetooth 框架的基本示例，我希望通过这个教程，加上WWDC视频，有用的一些文档能帮助你创建一个 BLE 项目，同时你也可以去参考一些文档示例，那你会发现我这教程中所有的 delegate 方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC 与内存管理]]></title>
    <link href="http://doruby.com/blog/2013/04/24/arc-with-memory-management/"/>
    <updated>2013-04-24T13:15:00+08:00</updated>
    <id>http://doruby.com/blog/2013/04/24/arc-with-memory-management</id>
    <content type="html"><![CDATA[<p>ARC: Automatic Reference Counting (自动引用计数)</p>

<p>ARC 是 iOS 5 后推出的一项为Objective - C程序在编译时提供自动内存管理的功能。ARC可以让你把注意力集中在你感兴趣的代码，减少开发中的内存管理步骤，简化开发。</p>

<p>它通过指定的语法，让编译器(LLVM 3.0)在编译代码时，自动生成实例的引用计数管理部分代码。有一点，ARC并不是GC，它只是一种代码静态分析（Static Analyzer）工具。</p>

<p>在过往我们通常使用的是MRC: Manual Reference Counting(手动内存管理)。这些规则将逐渐变为本能，你会发现少一个release的代码怎么看怎么别扭，从而减少或者杜绝内存管理的错误。可以说MRC的规则非常简单，但是同时也非常容易出错。往往很小的错误就将引起crash或者leak之类问题。</p>

<p>很多人担心内存管理不受自己控制，其实这是对于ARC机制了解不足从而不自信，所导致的对新事物的恐惧。</p>

<p>下面我们从几个方面来详细介绍ARC到底如何实现，如何使用，它的好处，注意事项等。</p>

<h2>需要的基本环境:</h2>

<p>ARC is supported in Xcode 4.2 for OS X v10.6 and v10.7 (64-bit applications) and for iOS 4 and iOS 5. Weak references are not supported in OS X v10.6 and iOS 4.</p>

<p><strong>注意：iOS4 不支持 weak 引用</strong></p>

<h2>原理</h2>

<!-- more -->


<p><img src="http://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Art/ARC_Illustration.jpg" alt="ARC Illustration" /></p>

<pre><code>ARC的一个基本原则: 只要某个对象被任一strong指针引用，那么它将不会被销毁。当对象没有被任何strong指针引用时，那么就将被销毁。
</code></pre>

<h2>默认行为</h2>

<p>对象默认为声明为 strong 类型, ARC 确保对象在函数体内是不会被 dealloc。比如</p>

<p>``` objc
- (void)takeLastNameFrom:(Person *)person {</p>

<pre><code>NSString *oldLastname = [self lastName];
[self setLastName:[person lastName]];
NSLog(@"Lastname changed from %@ to %@", oldLastname, [self lastName]);
</code></pre>

<p>}</p>

<p>```</p>

<h2>强制规则</h2>

<ul>
<li><p>你不能再调用 dealloc 或者实现、调用 retain, release, retainCount, autorelease, 同样@selector(retain), @selector(release)也是不允许的，
当然你可以实现 dealloc 方法，来管理你的实例变量，或者你会调用 [systemClassInstance setDelegate:nil]等.定制的 dealloc 方法不需要写 [super dealloc],这个动作会默认调用。</p>

<p>你仍然可以用 CFRetain, CFRelease 和相关Core Foundation方法。 如果要管理这类对象可以参考：(Managing Toll-Free Bridging 管理自由桥接)</p></li>
<li><p>你不能使用 NSAllocateObject 或 NSDeallocateObject</p>

<p>创建对象用 alloc</p></li>
<li><p>你不能在 C 结构体中使用对象指针</p>

<p>因此下面代码是不可用的</p></li>
</ul>


<p>``` objc
typedef struct {</p>

<pre><code>UIImage *selectedImage;
UIImage *disabledImage;
</code></pre>

<p>} ButtonImages;</p>

<p>```
  建议是用 OC类来管理它们</p>

<ul>
<li><p>不能随意在 id 与 void * 之间随意转换</p>

<p>编译器同样是无法管理 void * 这类 Core Foundation类型的东东，都要用 Managing Toll-Free Bridging 进行生命同期的管理。</p></li>
<li><p>你不能再使用 NSAutoreleasePool 对象</p>

<p>ARC 提供了性能更好的 @autoreleasepool block 替换原来这类使用方式。</p></li>
<li><p>你不能使用内存区</p>

<p>你不需要再使用 NSZone 等这类对象，因为现在Objective-C运行时已经忽略NSZone了，所以没必要再使用NSZone了。</p></li>
<li><p>你不能使用 new 开头的属性名，但你可以手动指定 getter 方法名</p>

<p>例如:</p></li>
</ul>


<p>``` objc
// 非法:
@property NSString *newTitle;</p>

<p>// OK:
@property (getter=theNewTitle) NSString *newTitle;
```</p>

<h1>ARC 新的对象生命周期声明</h1>

<ul>
<li>属性</li>
</ul>


<p>``` objc
// 用 strong 代替 retain, @property(retain) MyClass <em>myObject;
@property(strong) MyClass </em>myObject;</p>

<p>// 用 weak 代替 assign "@property(assign) MyClass <em>myObject;"
// 实例变量被释放后，会自动赋予 nil 指针，省得我们自己在手动赋nil操作。
@property(weak) MyClass </em>myObject;</p>

<p>```</p>

<p>在 ARC 中 strong 将是默认的类型.</p>

<ul>
<li>变量</li>
</ul>


<p>变量同样有以下几种管理生命周期的声明</p>

<p><code>objc
__strong
__weak
__unsafe_unretained
__autoreleasing
</code></p>

<p>__unsafe_unretained 类似原来的 assign</p>

<p>所以你可以这样声明这些对象</p>

<p><code>objc
MyClass * __weak myWeakReference;
MyClass * __unsafe_unretained myUnsafeReference;
</code></p>

<p>需要注意的是 __weak 变量在栈中的情况，例如:</p>

<p><code>objc
NSString * __weak string = [[NSString alloc] initWithFormat:@"First Name: %@", [self firstName]];
NSLog(@"string: %@", string);
</code></p>

<p>尽管 string 被实例化，但由于 string 声明为 weak 类型，它没有 strong 这个引用，所以他在赋值后立即就被释放了,在Log它时，它已经被释放了。</p>

<h2>同样你也要注意对象值传递. 比如下面的代码</h2>

<p>``` objc
NSError *error;
BOOL OK = [myObject performOperationWithError:&amp;error];
if (!OK) {</p>

<pre><code>// Report the error.
// ...
</code></pre>

<p>```</p>

<p>实际上这个代码是这样隐示声明的
<code>objc
NSError * __strong e;
</code></p>

<p>而函数是这样被声明了的</p>

<p><code>objc
-(BOOL)performOperationWithError:(NSError * __autoreleasing *)error;
</code></p>

<p>所以最后编译的结果就是:</p>

<p>``` objc
NSError * <strong>strong error;
NSError * </strong>autoreleasing tmp = error;
BOOL OK = [myObject performOperationWithError:&amp;tmp];
error = tmp;
if (!OK) {</p>

<pre><code>// Report the error.
// ...
</code></pre>

<p>```</p>

<p>当本地变量声明(<strong>strong *error)和函数的参数((NSError * </strong>autoreleasing <em>)error)不匹配的时候，编译器会创建一个临时变量。当你获得一个<strong>strong变量的地址时，你可以初始化一个id </strong>strong </em>的指针来声明 ，这样你就可以获得指针的原型，或者你可以声明一个变量为 __autoreleasing。</p>

<h1>避免循环引用</h1>

<p>你可以使用生命周期修饰符来避免Strong引用周期。例如，当你制作了一组父子结构的对象，而且父类要引用子类，则会出现Strong引用周期；反之，当 你将一个父类指向子类为strong引用，子类指向父类为weak引用，就可以避免出现Strong引用周期。当对象包含block objects时，这样的情况会变的更加隐性。</p>

<p>在手动内存管理模式下， <code>__block id x</code>; x不会被 retaining
在ARC模式下，<code>__block id x</code> , 默认被retaining</p>

<p>为了使手动内存管理模式代码可以在ARC模式下正常工作， 你可以用 <code>__unsafe_unretained</code> 来修饰 <code>__block id</code> x;。就和"<strong>unsafe_unretained"字面上的意思一样, 不过,这样一个non-retained变量是危险的(因为它会变成一个野指 针) 会带来不良后果。有两种更好一点的方法来处理，一是使用</strong>weak (当你不需要支持iOS 4或OS X v10.6), 二是设__block值为nil，结束他的生命周期。</p>

<ul>
<li>这是MRC时代处理 __block 里对象释放问题:</li>
</ul>


<p><code>objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {
   [myController dismissViewControllerAnimated:YES completion:nil];
};
[self presentViewController:myController animated:YES completion:^{
   [myController release];
}];
</code></p>

<p>你可以使用 __block修饰符然后设置myController的值为nil 替代上面的方式:</p>

<p>``` objc
MyViewController * __block myController = [[MyViewController alloc] init…];
// ...
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[myController dismissViewControllerAnimated:YES completion:nil];
myController = nil;
</code></pre>

<p>};
```</p>

<p>无伦哪种形式，你都可以使用一个 weak 引用对象避免循环引用:</p>

<p>``` objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyViewController = myController;
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>[weakMyViewController dismissViewControllerAnimated:YES completion:nil];
</code></pre>

<p>};
```</p>

<p>在某个时候这个对象，如果放在异步执行时，对象可能已经被释放，所以需要一个 strong 的对象把它 hold 住。</p>

<p>``` objc
MyViewController *myController = [[MyViewController alloc] init…];
// ...
MyViewController * __weak weakMyController = myController;
myController.completionHandler =  ^(NSInteger result) {</p>

<pre><code>MyViewController *strongMyController = weakMyController;
if (strongMyController) {
    // ...
    [strongMyController dismissViewControllerAnimated:YES completion:nil];
    // ...
}
else {
    // Probably nothing...
}
</code></pre>

<p>};
```</p>

<h2>栈里的变量初始化即为 nil</h2>

<p>使用ARC后， strong, weak, autoreleasing 栈里的变量默认初始为nil
``` objc
- (void)myMethod {</p>

<pre><code>NSString *name; // 这里 name 已经被赋予了nil指针， 所以下面的代码不会出错。
NSLog(@"name: %@", name);
</code></pre>

<p>}
```</p>

<h2>修改编译的Flag 打开和关闭 ARC</h2>

<p>如果有遇到第三方插件，或有一些文件你不想用 ARC 来控制，可以在 Build Phases > Compile Sources > 某个文件上 > Compiler Flags: -fno-objc-arc</p>

<p>相互如果想在部分文件中用到 arc 则标记上: -fobjc-arc</p>

<p><img src="/assets/compiler_flags_arc.png" alt="Compiler flags for arc" /></p>

<h2>Managing Toll-Free Bridging</h2>

<p>由于ARC不能管理Core Foundation Object的生命周期，所以在Core Foundation和ARC之间，我们需要使用到<strong>bridge,</strong>bridge_retained和__bridge_transfer三个转换关键字。</p>

<p>__bridge只做类型转换，但是不修改对象（内存）管理权；</p>

<p>__bridge_retained（也可以使用CFBridgingRetain）将Objective-C的对象转换为Core Foundation的对象，同时将对象（内存）的管理权交给我们，后续需要使用CFRelease或者相关方法来释放对象；</p>

<p>__bridge_transfer（也可以使用CFBridgingRelease）将Core Foundation的对象转换为Objective-C的对象，同时将对象（内存）的管理权交给ARC。</p>

<h2>使用weak property声明Outlet</h2>

<p>在被ARC处理过的iOS和OS X中，声明的outlets将会趋于统一。</p>

<p>一般来说outlets变量被修饰为weak，但是如果outlets变量的所有者是nib文件中的top-level对象(或者是storyboard scene)时，应被修饰为strong。</p>

<p>详细参考Resource Programming Guide中的“Nib Files”。</p>

<p>当我们使用 Interface Builder 生成Outlet对象的时候，一般都是作为 subview 来使用的。比如 UIViewController 的view。所以说Outlet的持有者就是superview对象，即有“父子”关系。我们知道，当对象间有“父子”关系时，需要使用弱参照，以避免“循环参照”。</p>

<p>ViewController 本身是不会作为Outlet的所有者的，所以使用weak property声明。</p>

<p><img src="/assets/arc_outlet_weak_property.png" alt="arc outlet weak property" /></p>

<p>简化viewDidUnload</p>

<p>Outlet都使用weak property声明的时候，还有一个好处，就是简化viewDidUnload的处理。</p>

<p>iOS在系统内存不足的时候，UIViewController会将没有表示的所有view做unload处理，即调用viewDidUnload接口。</p>

<p>所以，如果是强参照的情况下，需要释放所有权，</p>

<p>``` objc
@property (nonatomic, strong) IBOutlet UILabel *label;</p>

<p>-(void) viewDidUnload {</p>

<pre><code>self.label = nil; // 取消强参照，释放所有权
[super viewDidUnload];
</code></pre>

<p>}
```</p>

<p>如果没有 self.label = nil 的处理，那么 UIViewController 将不会释放 label 的所有权；结果，系统是调用了unload，但是subview对象始终留在内存中。随着界面上控件的增多，内存泄露会越来越大。</p>

<p>如果使用的是weak property声明的话，会是怎样的呢？</p>

<p><code>objc
@property (nonatomic, weak) IBOutlet UILabel *label;
</code></p>

<p>这时，系统在unload时，由于label没有被强参照，更加ARC的规则，这时，label的对象即被释放。并在释放的同时，变量自动指向nil。</p>

<p>``` objc
- (void)viewDidUnload {</p>

<pre><code>// 这里什么也不用管
[super viewDidUnload];
</code></pre>

<p>}
```</p>

<p>其实，如果我们的viewDidUnload只是用来释放Outlet用的话，那么该函数也可以不被重载的。</p>

<p>什么时候要用strong property</p>

<p>由上我们也可以看到，并不是所有的Outlet都用weak来声明都是正确的；当使用Interface Builder生成的第一层的view或者windows被作为Outlet来使用的话，那么不是不能声明为weak property的。（比如，Storyboard的各个scene）</p>

<h1>转化原MRC项目到ARC</h1>

<ul>
<li><p>用Xcode自带工具转换MRC项目到ARC:
Edit > Refactor > Convert to Objective-C ARC)</p>

<p><img src="/assets/tool_for_convert_to_oc_arc.png" alt="Provides a tool that convert to ARC" /></p>

<p>在这个选项下，还有一个 Convert to Modern Objective-C Syntax.. 转化成更现代的写法, 有兴趣的可以试试。:)</p>

<p>在转化的过程中，编译器会先对代码进行检查，如果遇到错误警告，可以根据提示进行处理后，再进行转化 (如果你要无视这些错误可以在Preferences 里设定 Continue building after errors)</p></li>
<li><p>将项目用ARC方式编译
Build Settings -> LLVM compiler 将 Objective-C Automatic Reference Counting 设置为 Yes</p>

<p><img src="/assets/convert_to_arc_in_llvm.png" alt="Convert to ARC in LLVM" /></p></li>
</ul>


<h1>常见问题</h1>

<ul>
<li><p>通常遇到的错误有这样一些：</p>

<p><code>Receiver type ‘X’ for instance message is a forward declaration</code></p>

<p>这往往是引用的问题。ARC要求完整的前向引用，也就是说在MRC时代可能只需要在.h中申明@class就可以，但是在ARC中如果调用某个子类中未覆盖的父类中的方法的话，必须对父类.h引用，否则无法编译。</p>

<p><code>Switch case is in protected scope</code></p>

<p>现在switch语句必须加上{}了，ARC需要知道局部变量的作用域，加上{}后switch语法更加严格，否则遇到没有break的分支的话内存管理会出现问题。</p>

<p><code>A name is referenced outside the NSAutoreleasePool scope that it was declared in</code></p>

<p>这是由于写了自己的 autoreleasepool，而在转换时在原来的pool中申明的变量在新的@autoreleasepool中作用域将被局限。解决方法是把变量申明拿到pool的申请之前。</p>

<p><code>ARC forbids Objective-C objects in structs or unions</code></p></li>
<li><p>ARC 需要你指定 super init 的结果到 self
 [super init]; // 这将是无效的</p>

<p> 推荐用
<code>objc
 self = [super init];
 if (self) {
  ...
</code></p></li>
</ul>


<p>实例变量会变成 strong 类型</p>

<p>在用 ARC 之前, thing 这个变量是一个 weak 类型</p>

<p>``` objc
@interface MyClass : Superclass {</p>

<pre><code>id thing; // Weak reference.
</code></pre>

<p>}
// ...
@end</p>

<p>@implementation MyClass
- (id)thing {</p>

<pre><code>return thing;
</code></pre>

<p>}
- (void)setThing:(id)newThing {</p>

<pre><code>thing = newThing;
</code></pre>

<p>}
// ...
@end
```</p>

<p>使用 ARC 后，thing 变量实际上是默认用了 strong 类型，所以如果你要想继续使用 weak 类型，必须显示声明</p>

<p>``` objc
@interface MyClass : Superclass {</p>

<pre><code>id __weak thing;
</code></pre>

<p>}
// ...
@end</p>

<p>@implementation MyClass
- (id)thing {</p>

<pre><code>return thing;
</code></pre>

<p>}
- (void)setThing:(id)newThing {</p>

<pre><code>thing = newThing;
</code></pre>

<p>}
// ...
@end
```</p>

<p>或</p>

<p>``` objc
@interface MyClass : Superclass
@property (weak) id thing;
// ...
@end</p>

<p>@implementation MyClass
@synthesize thing;
// ...
@end
```</p>

<ul>
<li>首先，我们需要转变一下观念, 对于在.h中申明的实例变量：</li>
</ul>


<p>``` objc
@interface MainViewController : UIViewController<br/>
{</p>

<pre><code>NSOperationQueue *queue;
</code></pre>

<p>}
```</p>

<p>我们不妨仔细考虑一下，为什么在interface里出现了实例变量的申明？通常来说，实例变量只是在类的实例中被使用，而你所写的类的使用者并没有太多必要了解你的类中有哪些实例变量。而对于绝大部分的实例变量，应该都是protected或者private的，对它们的操作只应该用setter和getter，而这正是property所要做的工作。可以说，将实例变量写在头文件中是一种遗留的陋习。更好的写实例变量名字的地方应当与类实现关系更为密切，为了隐藏细节，我们应该考虑将它们写在@implementation里。好消息是，在LLVM3.0中，不论是否开启ARC，编译器是支持将实例变量写到实现文件中的。甚至如果没有特殊需要又用了property，我们都不应该写无意义的实例变量申明，因为在@synthesize中进行绑定时，我们就可以设置变量名字了，这样写的话可以让代码更加简洁。</p>

<p>在这里我们对实例变量申明移到.m里中。修改后的.h是这样的，十分简洁</p>

<p>``` objc
@implementation MainViewController
{</p>

<pre><code>NSOperationQueue *queue;  
</code></pre>

<p>}
```</p>

<p>这样的写法让代码相当灵活，而且不得不承认.m确实是这些实例变量的应该在的地方</p>

<p>参考资料:</p>

<ul>
<li><a href="http://developer.apple.com/library/ios/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i">About Memory Management</a></li>
</ul>


<p><img src="http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Art/memory_management_2x.png" alt="memory managment" /></p>

<ul>
<li><p><a href="http://developer.apple.com/library/ios/#releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Transitioning to ARC</a></p></li>
<li><p><a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#blocks">Objective-C Automatic Reference Counting</a></p></li>
</ul>

]]></content>
  </entry>
  
</feed>
